from fastapi import FastAPI, HTTPException, Request, UploadFile, File
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates
from app.models import SummarizeRequest, SummarizeResponse
import os
import shutil
from typing import List

app = FastAPI(title="Summarizer Service", version="0.1.0")
templates = Jinja2Templates(directory="app/templates")

@app.get("/", response_class=HTMLResponse)
async def read_root(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})

@app.post("/upload", response_class=HTMLResponse)
async def upload_files(request: Request, files: List[UploadFile] = File(...)):
    # TODO: Connect this to the actual processing service
    # For now, just mock the response for the UI
    results_html = ""
    for file in files:
        # Save temp file logic would go here
        
        # Mock result
        results_html += f"""
        <div class="result-item">
            <div class="result-title">{file.filename}</div>
            <p><strong>Type:</strong> {file.content_type}</p>
            <p><strong>Summary:</strong> This is a simulated semantic summary for the uploaded document. It would contain extracted entities and a description of the content generated by the multimodal model.</p>
        </div>
        """
    return results_html

@app.get("/health")
def health_check():
    return {"status": "ok", "service": "summarizer"}

@app.post("/summarize", response_model=SummarizeResponse)
async def summarize(request: SummarizeRequest):
    # TODO: Implement full logic connecting storage, pdf processing, and LLM
    return {
        "results": [
            {
                "id": doc.id,
                "description": f"Processed {doc.type} from {doc.source.mode}",
                "children": []
            }
            for doc in request.documents
        ]
    }
